<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Detailed Report: User Intent</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Reuse your existing libs/renderers -->
    <script src="https://cdn.zingchart.com/zingchart.min.js" defer></script>
    <script src="./charts-landing.js" defer></script>
    <script src="./charts-exit.js" defer></script>
    <script src="./charts-traffic-share.js" defer></script>

    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        margin: 12px;
        line-height: 1.35;
        background: #fafafa;
      }
      h1 {
        margin: 0 0 8px;
        font-size: 20px;
      }
      .links {
        margin: 6px 0 10px;
        font-size: 0.95rem;
      }
      .links a {
        margin-right: 10px;
      }
      .qa p {
        margin: 4px 0;
      }
      .meta {
        font-size: 12px;
        opacity: 0.75;
      }

      .wrap {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 10px;
      }
      .cards {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .card {
        background: #fff;
        border: 1px dashed rgba(0, 0, 0, 0.12);
        border-radius: 6px;
        padding: 10px;
      }
      .card h2 {
        margin: 0 0 6px;
        font-size: 15px;
      }
      .zc {
        width: 100%;
        height: 260px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
        background: #fff;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 6px;
        text-align: left;
      }
      th {
        background: rgba(0, 0, 0, 0.05);
      }

      @media (max-width: 1000px) {
        .wrap {
          grid-template-columns: 1fr;
        }
        .cards {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <h1>Detailed Report: User Intent</h1>
    <div class="links">
      <a href="./index.html">← Back to Dashboard</a>
    </div>

    <div class="qa">
      <p><strong>Question:</strong> What are users trying my website for?</p>
      <p>
        <strong>Answer:</strong>
        Since this site mainly hosts completed assignments,
        Home (/), the main page naturally has the
        largest share of views and is both the top landing and
       top exit. Most sessions look like quick check ins to confirm a
        submission or to open a specific deliverable. After Home, the most visited pages are the actual assignment links like
        <code>/hellodataviz.html</code>, <code>/database.html</code>, <code>/members/angelchavez.html</code>,
        <code>/index.html</code>, and <code>/cgi-bin/php-sessions-2.php</code>. Overall, the patterns reflect
        a submission/portfolio workflow rather than deep site exploration.
      </p>
      <p class="meta">
        Landing = first page per session; Exit = last page per session
        (preferring <code>activity.type="leave"</code> if present); Traffic
        Share = proportion of total pageviews in the fetched sample.
      </p>
    </div>

    <section class="wrap">
      <div class="cards">
        <article class="card">
          <h2>Top Landing Pages (All-Time)</h2>
          <div
            id="chartLanding"
            class="zc"
            aria-label="Top landing pages"
          ></div>
          <p class="meta">
            <strong>Why a bar chart?</strong>
            We're comparing pages/categories, not tracking time. Bars make the differences obvious, handle long paths,
            and let me sort by volume. Lines would imply a timeline but pies hide small but important pages.

          </p>
        </article>

        <article class="card">
          <h2>Top Exit Pages (All-Time)</h2>
          <div id="chartExit" class="zc" aria-label="Top exit pages"></div>
          <p class="meta">
            <strong>Why a bar chart?</strong>
            Exit counts are categorical comparisons, not a time series. A bar
            chart highlights which pages most often end a session and how they
            rank relative to each other, which is useful for spotting potential “dead
            ends” versus normal endpoints.
          </p>
        </article>
      </div>

      <article class="card">
        <h2>Traffic Share by Page (All-Time)</h2>
        <div
          id="chartTrafficShare"
          class="zc"
          aria-label="Traffic share by page"
        ></div>
        <p class="meta">
          <strong>Why a donut chart?</strong>
          This view is about composition,how total traffic is split across
          pages. A donut communicates proportion at a glance. I roll tiny 
          slices into “Other” so labels don't get messy but for deeper analysis we
          pair this with the table below.
        </p>
      </article>
    </section>

    <article class="card" style="margin-top: 10px">
      <h2>Pages Intent Overview (Top 10)</h2>
      <table id="intentGrid">
        <thead>
          <tr>
            <th>#</th>
            <th>Path</th>
            <th>Views</th>
            <th>Share</th>
            <th>Landings</th>
            <th>Exits</th>
            <th>Exit Rate</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <p class="meta">
        <strong>Why a grid?</strong>
        The grid provides exact values behind the charts,<em
          >Views, Share, Landings, Exits, Exit Rate</em
        >,and accommodates long page paths. It's the source of truth for precise
        comparisons and for citing numbers in the written answer.
      </p>
    </article>

    <article class="card" style="margin-top: 10px">
      <h2>Discussion</h2>
      <p>
        The data lines up with how I use the site. it's a
        homework portfolio. The Home (/) page
        has the most landings and exits, which basically means that many visits are
        quick check ins to open or verify a single assignment/file. The
        Traffic Share chart shows a long tail of assignment pages—some get most of the attention (like data-viz/database work),
        while others are opened occasionally. That looks exactly like TAs/students checking a specific submission.
      </p>
      <p>
        The Top Landingand Top Exit bars together suggest
        short, journey where you start on Home, jump to the assignment you need, then you're done. That's expected
        for a this kind off site and doesn't imply a navigation problem, ust that
        “exploration” isn't the goal. What matters is that the main links are
        easy to find and each assignment page opens without friction.
      </p>
      <p>
       <strong>What this means for TAs/students:</strong> keep the portfolio index 
       clear, name assignment links consistently,
        and make sure each assignment page loads reliably and gets straight to the 
        point.

      </p>
      <p class="meta">
        <strong>Limitations & assumptions:</strong> landings/exits are derived
        from the first/last page per session in the sampled logsbut some sessions
        are very short and background tabs can skew things. Small pages in the tail
        can move around with limited data. The trends for the top pages
        are the most reliable.
      </p>
    </article>

    <script>
      // ---------- Helpers ----------
      async function j(url) {
        const r = await fetch(url, { credentials: "include" });
        const t = await r.text();
        if (!r.ok)
          throw new Error(url + " -> " + r.status + "\n" + t.slice(0, 160));
        try {
          return JSON.parse(t);
        } catch {
          throw new Error(url + " non-JSON:\n" + t.slice(0, 160));
        }
      }
      const arr = (x) =>
        Array.isArray(x)
          ? x
          : x && Array.isArray(x.data)
          ? x.data
          : x && Array.isArray(x.rows)
          ? x.rows
          : x && Array.isArray(x.result)
          ? x.result
          : [];
      const tsOf = (r) => Number(r.ts || r.timestamp || 0);
      function pathOf(r) {
        let p = r.path || "";
        if (!p) {
          const u = r.page_url || r.pageUrl || "";
          if (u) {
            try {
              p = new URL(u).pathname;
            } catch {}
          }
        }
        return p;
      }

      function fillGrid(rows) {
        const tb = document.querySelector("#intentGrid tbody");
        tb.innerHTML = "";
        rows.forEach((r, i) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
          <td>${i + 1}</td>
          <td>${r.path}</td>
          <td>${r.views}</td>
          <td>${r.share.toFixed(1)}%</td>
          <td>${r.landings}</td>
          <td>${r.exits}</td>
          <td>${(r.exitRate * 100).toFixed(1)}%</td>`;
          tb.appendChild(tr);
        });
      }

      // ---------- Main (reuses your chart renderers) ----------
      (async function () {
        try {
          const [statRaw, actRaw] = await Promise.all([
            j("/api/static?limit=8000"),
            j("/api/activity?limit=8000"),
          ]);
          const stat = arr(statRaw),
            act = arr(actRaw);

          // Views per path
          const viewCounts = new Map();
          for (const r of stat) {
            const p = pathOf(r);
            if (!p) continue;
            viewCounts.set(p, (viewCounts.get(p) || 0) + 1);
          }
          const totalViews =
            [...viewCounts.values()].reduce((a, b) => a + b, 0) || 1;

          // Landings (first page per session)
          const firstBySession = new Map();
          for (const r of stat) {
            const sid = r.session_id || r.sessionId;
            if (!sid) continue;
            const t = tsOf(r);
            if (!t) continue;
            const p = pathOf(r);
            if (!p) continue;
            const cur = firstBySession.get(sid);
            if (!cur || t < cur.ts) firstBySession.set(sid, { ts: t, path: p });
          }
          const landingCounts = new Map();
          for (const { path } of firstBySession.values())
            landingCounts.set(path, (landingCounts.get(path) || 0) + 1);

          // Exits (last page per session; prefer activity.type="leave" at same/later ts)
          const lastBySession = new Map();
          function consider(row) {
            const sid = row.session_id || row.sessionId;
            if (!sid) return;
            const t = tsOf(row);
            if (!t) return;
            const p = pathOf(row);
            if (!p) return;
            const isLeave = String(row.type || "").toLowerCase() === "leave";
            const cur = lastBySession.get(sid);
            if (
              !cur ||
              t > cur.ts ||
              (t === cur.ts && isLeave && !cur.isLeave)
            ) {
              lastBySession.set(sid, { ts: t, path: p, isLeave });
            }
          }
          for (const r of stat) consider(r);
          for (const r of act) consider(r);

          const exitCounts = new Map();
          for (const { path } of lastBySession.values())
            exitCounts.set(path, (exitCounts.get(path) || 0) + 1);

          // ---- Grid rows (Top 10 by views) ----
          const rows = [...viewCounts.entries()]
            .map(([path, views]) => ({
              path,
              views,
              share: (views / totalViews) * 100,
              landings: landingCounts.get(path) || 0,
              exits: exitCounts.get(path) || 0,
            }))
            .map((r) => ({ ...r, exitRate: r.views ? r.exits / r.views : 0 }))
            .sort((a, b) => b.views - a.views);
          fillGrid(rows.slice(0, 10));

          // ---- Charts ----
          // Landing (Top 5)
          const topLand = [...landingCounts.entries()]
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
          renderLanding(
            topLand.map(([p]) => p),
            topLand.map(([, n]) => n)
          );

          // Exit (Top 5)
          const topExit = [...exitCounts.entries()]
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
          renderExit(
            topExit.map(([p]) => p),
            topExit.map(([, n]) => n)
          );

          // Traffic Share (fold small slices into "Other" like on dashboard)
          const sorted = rows.slice().sort((a, b) => b.views - a.views);
          const MIN_PCT = 3,
            MAX_SLICES = 7;
          const kept = [];
          let other = 0;
          for (const r of sorted) {
            if (kept.length < MAX_SLICES && r.share >= MIN_PCT)
              kept.push([r.path, r.views]);
            else other += r.views;
          }
          if (other) kept.push(["Other", other]);
          renderTrafficShare(
            kept.map(([p]) => p),
            kept.map(([, n]) => n)
          );
        } catch (e) {
          console.error(e);
          // Optionally show a small inline message if needed
        }
      })();
    </script>
  </body>
</html>
